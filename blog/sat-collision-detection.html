<!DOCTYPE html>

<html lang='en'>

<head>
    <title>Cristi Cismas | 2D SAT collision detection</title>

    <meta name="description" content="Hi! This is a pretty lengthy article about AABB and SAT collision detection. I tried to explain these concepts as well as I could from a programming point of view, but there may be slight mistakes. Reading this does have some prerequisites however, such as knowing a bit of linear algebra, vector math and what a coordinate system is." />

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preload" as="font" href="/font/LibreBaskerville.ttf" crossorigin>
    <link rel="preload" as="font" href="/font/FiraCode.ttf" crossorigin>
    <link rel="preload" as="font" href="/font/Inter.woff2" crossorigin>

    <link rel='stylesheet' href='../styles.css' />

    <style type="text/css">
        body {
            background: #161826;
        }
    </style>
</head>

<body>
    <header>
        <div class="inner-header-container">

            <a class='link' href="/index.html">Home</a>

            <div class="right-side">
                <a class='link' href="/blog.html">
                    <img src='/icons/blog.svg' width='18' height='18' alt='' />
                    Blog</a>
                <a class='link' href="/projects.html">
                    <img src='/icons/projects.svg' width='18' height='18' alt='' />
                    Projects</a>
            </div>
        </div>
    </header>

    <main>
        <section class='section blog'>
            <div>
                <div id='table-of-contents'>
                    <p class='toc-title'>Table of contents</p>
                </div>
                <h1> 2D SAT collision detection</h1><br /><h2> Introduction</h2><br /><p>Hi! This is a pretty lengthy article about AABB and SAT collision detection. I tried to explain these concepts as well as I could from a programming point of view, but there may be slight mistakes. Reading this does have some prerequisites however, such as knowing a bit of linear algebra, vector math and what a coordinate system is.</p><br /><h2> The principle</h2><br /><p>Before understanding the Separating Axis Theorem, it would be very helpful to first understand the simpler cousin of the algorithm, AABB (Axis-Aligned Bounding Box), since they both work on the same base principle. Once you understand AABB collision detection, SAT becomes much simpler. If you already know how AABB detection works, feel free to skip the next section.</p><br /><h2> AABB Collision algorithm</h2><br /><p>AABB is a simple collision detection algorithm that only works when all objects are aligned on the world axes (ie. no rotation of the objects or the axes).</p><br /><p>The algorithm itself is simple to understand, all you have to do is compare the left-most and right-most vertices of each object on the x axis, and the top and bottom vertices on the y axis. If the ranges provided by these vertices intersect on both axes, you have collision, otherwise, you do not.</p><br /><img src="../images/SAT/aabb_no_collision_simple.png" alt="AABB Collision example with no collision between two rectangles."/><br /><br /><p>As you can easily see, there is no collision between the two rectangles in this case. On a computer program, let's check the y axis first, according to the logic from above.</p><br /><p>To do this we will need to first find the highest and lowest points of both objects. Do this by checking the y position of all points. Once you have found the 2 points for each object, we should look at their projections onto the y axis (you don't need to project anything in code for the AABB algorithm, I'm just using this illustration to show what happens).</p><br /><img src="../images/SAT/aabb_no_collision_projected_y.png" alt="AABB collision example with the highest and lowest points projected on the y axis."/><br /><br /><p>As you can see, the two ranges intersect. That means that we have collision on the y axis. Now we need to check the x axis as well, as we can only be sure we have no collision when all axes have been checked. If we had no collision on the y axis, that would have meant that the algorithm is done and the two objects do not touch each other, so we could have exited early, to avoid any additional calculations. This early exit strategy will also later apply to the SAT algorithm.</p><br /><p>Now, onto the x axis. Do the same as before regarding the point selection, only this time take the left-most and right-most points of each object. If we project the points onto the x axis, this is what the projection would look like:</p><br /><img src="../images/SAT/aabb_no_collision_projected_x.png" alt="AABB collision example with the left-most and right-most points projected on the x axis."/><br /><br /><p>We can see that the ranges of the 2 rectangles do not touch. That means that the job is done, and there is no collision between the two objects.</p><br /><blockquote> Remember, if we can find a gap between the two objects, it means we have no collision.</blockquote><br /><p>Projecting the vectors is something that we will cover in the SAT section of this article. Luckily, the code implementation doesn't include any projection for AABB collision detection, so it is actually simpler than the illustration. We only need to compare the x and y components of the edge points, since their projected points would have the same coordinates along the axis anyways.</p><br /><p>This is the whole AABB algorithm explained, and will serve as a solid base for understanding the SAT algorithm.</p><br /><h2> SAT Collision algorithm</h2><br /><p>The Separating Axis Theorem states that if two convex shapes do not overlap, there <b>must</b> exist a line (axis) that separates them. You could even see this phenomenon in our simple rectangle example, where the y axis was (one of) the separating axes between the two objects.</p><br /><img src="../images/SAT/aabb_no_collision_separating_axis.png" alt="AABB collision example with the y axis as the separating axis."/><br /><br /><p>You may have noticed that I said the y axis was only <b>one of</b> the separating axes. That's because if the objects are not intersecting, there can be an infinite number of separating axes. So, how do we find one axis that separates the objects, out of an infinite number of possibilities?</p><br /><p>To answer this, let's first change the illustration to a proper example where SAT would be useful. As I previously wrote, AABB detection doesn't help us anymore if the objects are rotated. Let's rotate them, and try the AABB algorithm again!</p><br /><img src="../images/SAT/aabb_rotated_projected.png" alt="AABB collision example with the y axis as the separating axis."/><br /><br /><p>This example looks a little bit busy, so let me explain what's going on.</p><br /><p>We have slightly rotated both objects, and moved them closer together to show how AABB fails on rotated objects. Then, we are applying the same principle to the objects, we are projecting the <b>minimum</b> and <b>maximum</b> points onto the axis to see if they intersect. This time though, they intersect on both the x axis and the y axis, even though we can see that <b>the objects don't actually touch</b>.</p><br /><p>To get around this limitation, we need to efficiently find an axis that separates both of these shapes. Such an axis can be found by treating the <b>normal vectors</b> of each <b>edge</b> as a <b>separate axis</b>, and using AABB principle for each one of these axes.</p><br /><p>I will switch to triangles now instead of rectangles, to have as few edges (axes) as possible, and illustrate the example more clearly, but please note, this algorithm will work with any polygon that is convex. I will illustrate later how this fails with concave shapes.</p><br /><img src="../images/SAT/sat_no_collision_triangles_simple.png" alt="SAT collision example with 2 triangles that are not colliding"/><br /><br /><p>I've also taken the liberty of drawing the normals for each edge (the little arrows perpendicular to each edge). A normal is just a vector that is perpendicular to another vector, in this case perpendicular to the triangle edges.</p><br /><p>These normals are now the axes that we need to project the minimum and maximum vertices on, and check for overlapping ranges. If any of the axes has a gap between the shapes, that means that we have found our separating axis, and we can exit early knowing that there is no collision. </p><br /><p>This algorithm is slightly more involved than AABB, since we now need to calculate the vector of each edge, then calculate the normal of the edge, and then project the vertices onto the normal to find the shape's minimum and maximum points. Let's do this together, step by step.</p><br /><p>First, let's take an edge at random from the B shape. To compute the edge vector, we simply need to subtract 2 adjacent vectors, in our case, <b>v1</b> and <b>v2</b>.</p><br /><pre><code>edge = v1 - v2
</code></pre><br /><br /><img src="../images/SAT/sat_no_collision_triangles_edge.png" alt="SAT collision example with 2 triangles, with one edge of the B triangle marked"/><br /><br /><p>Now that we have the edge vector, we need to find the normal vector for that edge. This can simply be done by inverting one of the components of the vector, and switching the place of the components.</p><br /><pre><code>normal({ x, y }) == { y, -x }
</code></pre><br /><br /><p>or</p><br /><pre><code>normal({ x, y }) == { -y, x }
</code></pre><br /><br /><p>This operation will give us one of the normals of the edge (the edge has 2 normals, two vectors perpendicular to it with an opposite direction. We don't care which one we compute, since the projection of the vector will be the same).</p><br /><img src="../images/SAT/sat_no_collision_triangles_normal.png" alt="SAT collision example with 2 triangles, and the normal of one edge shown"/><br /><br /><p>The third step we need to do is project the vertices. You can directly do this in code, but first I want to pull the normal apart from the shape so we can clearly see what's going on in the illustration.</p><br /><p>We can freely move the normal and increase its length for the sake of visualizing it more clearly. In code, you will need to keep your normal vector normalized (unit length). As long as we don't rotate the normal axis, the principle is the same.</p><br /><img src="../images/SAT/sat_no_collision_triangles_long_normal.png" alt="SAT collision example with 2 triangles, and the normal of one edge shown apart from the triangle"/><br /><br /><p>Now we can visualize the projections more clearly. Let's project all the vertices of the B triangle onto our normal. Imagine a projection as drawing a perpendicular line, from a point (your vertex), onto a vector (your normal), and computing the length to the projected point along the normal.</p><br /><img src="../images/SAT/sat_no_collision_triangles_projected.png" alt="SAT collision example with 2 triangles, the vertices of the second triangle are projected onto the chosen normal"/><br /><br /><p>Here we can see that the minimum point on the axis is the projection of <b>v3</b>, and the maximum point along the axis is the projection of <b>v1</b>. In code, we can find this out by computing the projection length of each point. The projection length is the result of the <b>dot product</b> between the vertex and the normal axis.</p><br /><p>At this point the normal should also be normalized (unit length).</p><br /><pre><code>normal = normalize(normal)
projection_length = dot(vertex, normal)
</code></pre><br /><br /><blockquote> Please note that the dot product returns a scalar value (this could be a float or int in your coordinate system, it's simply a length), not a vector.</blockquote><br /><p>Now that we know the minimum and maximum points of our projected shapes onto the normal, we have a range of values that the shape occupies on our axis.</p><br /><img src="../images/SAT/sat_no_collision_triangles_first_range.png" alt="SAT collision example with 2 triangles, the range of the second triangle's projections is shown on the normal"/><br /><br /><p>Let's run the same logic on the <b>A triangle</b> and see where we stand with the projections.</p><br /><img src="../images/SAT/sat_no_collision_triangles_both_projected.png" alt="SAT collision example with 2 triangles, the range of the both triangle's projections are shown on the normal, and there is collision between them"/><br /><br /><p>As you can see, we have detected overlapping ranges on this normal, so this normal is not a separating axis! We need to run the same logic on all the normals in our shapes, until we find one that has no overlap between the projections, or until we run out of normals.</p><br /><p>Let's go ahead and check another normal: the normal on the edge formed by the vertices <b>v1</b> and <b>v3</b>. This time I chose a normal that is a separating axis.</p><br /><img src="../images/SAT/sat_no_collision_triangles_v2.png" alt="SAT collision example with 2 triangles, and the normal of another edge illustrated"/><br /><br /><p>Like before, I extracted the normal below the illustration and increased its length so we can see the projections better.</p><br /><p>Now let's project the minimum and maximum points of each shape, and see if the ranges intersect:</p><br /><img src="../images/SAT/sat_no_collision_v2_projected.png" alt="SAT collision example with 2 triangles, with the ranges project and not intersecting"/><br /><br /><p>The two ranges do not intersect, and that means we have NO collision between the two objects. We can exit our algorithm early and avoid any further computation. If we had detected collision on this axis as well, we would have needed to keep checking all other normals from <b>triangle B</b>, and then check all the normals from <b>triangle A</b> as well.</p><br /><p>This is the basis of the SAT algorithm done for convex to convex polygon collision detection. If you have slightly more complex needs than this, or want some ideas about how you could optimize this algorithm, you might find something useful in the chapter below.</p><br /><h2> Additional shapes</h2><br /><h3> Circle to Circle</h3><br /><p>Circle to circle collision detection doesn't involve the SAT algorithm at all, it's just a matter of checking if the sum of the radii is less than the distance between the two centers of the circles.</p><br /><img src="../images/SAT/sat_circle_to_circle.png" alt="SAT collision example with 2 circles"/><br /><br /><h3> Circle to Polygon</h3><br /><p>Circle to polygon however, does require us to use the concepts previously learned, but we need to account for the fact that circles have no edges. As such, we can only compute the normals of the triangle in this case, and project both shapes onto those normals. Let's see how that looks like:</p><br /><img src="../images/SAT/sat_triangle_to_circle.png" alt="SAT collision example with one triangle and one circle"/><br /><br /><p>After we have the projections, the algorithm follows as before. Now the only question is, how do we project the circle? Let's get rid of the triangle for a second.</p><br /><img src="../images/SAT/sat_circle.png" alt="SAT collision example with one circle with a certain center and radius marked"/><br /><br /><p>All the data you need for the projection is the position of the circle's center (let's call this C), and the radius (called r). To get the minimum and maximum points of the circle, we need to compute 2 different vectors, for the furthest parts of the circle along the axis. In fact, we can compute a single vector and invert it, since the circle "edges" will always be in opposite directions and have the same length (the length of the radius).</p><br /><p>To get a vector along the axis, we can normalize the normal axis (set its length to 1) in order to get a unit vector with the axis' direction, and then multiply it by the radius to get a vector of the same length as the radius of the circle. Then we need to add the position of the circle (its center) to this vector. The result will be the furthest point on the circle's diameter, in the direction of our axis. Let's call this P1</p><br /><pre><code>P1 = center + (normalize(normal_axis) * radius)
</code></pre><br /><br /><p>To get the opposite point we can just subtract the radius vector from the center of the circle:</p><br /><pre><code>P2 = center - (normalize(normal_axis) * radius)
</code></pre><br /><br /><p>This is where the points of our calculation will sit on the shape:</p><br /><img src="../images/SAT/sat_circle_points.png" alt="SAT collision example with one circle that had the furthest points along the axis marked"/><br /><br /><p>The rest of the algorithm follows as before, we just project these points onto the axis as if they were vertices of a polygon, and check if there is any collision on the axis. We do this for each axis of the polygon until we find no collision or the normals of the polygon are exhausted.</p><br /><h3> Why concave polygons don't work (and a workaround)</h3><br /><p>Simply put, there are situations in which the objects don't collide, but there is also no axis that separates the two objects.</p><br /><img src="../images/SAT/sat_concave_line.png" alt="SAT collision example with a convex and a concave polygon, there is no separating line"/><br /><br /><p>There is a possible workaround for this issue, which is to separate the concave polygon into multiple convex polygons, and check their collisions separately. This can however get pretty expensive to compute if you have complex concave shapes.</p><br /><img src="../images/SAT/sat_concave_separated.png" alt="SAT collision example with a convex polygon, and a concave polygon that is split in 2 convex polygons"/><br /><br /><p>If neither <b>B1</b>, nor <b>B2</b> collide with <b>A</b>, there is no collision between the convex polygon and the concave polygon.</p><br /><p>Explaining how to separate a concave polygon into convex polygons is beyond the scope of this article. If you need it, you should look into <b>convex decomposition</b>.</p><br /><h2> Some possible optimizations</h2><br /><ul><li>For any shape with parallel edges, such as rectangles and rhombi, you can skip checking <b>half</b> of the normals, since half of them will just be pointing in the opposite direction from the others, but this algorithm doesn't care about the direction of the axes.</li><li>If you need to check the collision between the same exact shape type, you can skip getting the normals of one of the shapes completely, you don't need to compute the projections on the same axes twice.</li><li>Depending on your use-case, you may choose to only check the collision of shapes that are close to each other, and discard the shapes that sit at large distances outright.</li><li>This algorithm is very easy to run on multiple threads with a lot of shapes, since you just need to generate pairs of shapes and split them up among the available threads.</li></ul><br /><h2> Additional resources</h2><br /><p>If you need more visual examples to understand the algorithm, you may have better luck with these youtube videos:</p><br /><ul><li><a href="https://www.youtube.com/watch?v=dn0hUgsok9M">How 2D Game Collision Works (Separating Axis Theorem)</a></li><li><a href="https://www.youtube.com/watch?v=-EsWKT7Doww">Collision Detection with SAT (Math for Game Developers)</a></li></ul><br /><p>For 3D applications you may prefer to use the GJK (Gilbert-Johnson-Keerthi) algorithm since it is more efficient with a wider variety of convex shapes, although it is more involved and complex than SAT. To learn this I recommend Reductible's video on the subject: <a href="https://www.youtube.com/watch?v=ajv46BSqcK4">A Strange But Elegant Approach to a Surprisingly Hard Problem (GJK Algorithm)</a>.</p><br /><p>You may also choose to adapt the SAT algorithm to work with 3D, in which case you will need to compute the <b>face</b> normals, instead of the <b>edge</b> normals as we did for 2D.</p><br /><p>For more complex use-cases, such as physics interactions, predictive collision detection, ragdolls, I strongly recommend checking any of Box2D's <a href="https://box2d.org/documentation/">documentation</a> or <a href="https://box2d.org/publications/">publications</a></p><br /><h2> Thanks for reading!</h2><br /><p>If this article helped you, feel free to share it with others! If you have any feedback, or something wasn't clear enough, I'd love to hear about it, so please send me an email at <a href="mailto:cristicismas@pm.me">cristicismas@pm.me</a>.</p><br />
            </div>
        </section>
    </main>

    <section id='contact'>
        <h1 id='contact-title'>Contact Info</h1>

        <p>
            If you have any questions, suggestions, or business inquiries,<br />please contact me at <a class='link'
                href="mailto:cristicismas@pm.me">
                <img src='/icons/mail.svg' width='18' height='18' alt='' />
                cristicismas@pm.me</a>
        </p>
    </section>

    <footer>
        <p class="copyright">&copy; 2026 Cristi Cismas</p>
    </footer>

    <script src='/table_of_contents.js'></script>
</body>

</html>
